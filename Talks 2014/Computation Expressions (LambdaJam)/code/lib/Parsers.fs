module Parsers

type Parser<'T> = P of (list<char> -> seq<'T * list<char>>)

/// Run the parser and return the first result (or None)
let run (P f) = List.ofSeq >> f >> Seq.map fst >> Seq.tryPick Some

/// Parser that succeeds without consuming any input
let unit v = P (fun buffer -> seq [v, buffer])

/// Runs the first parser and then a parser 
/// generated by the provided function
let bind f (P p1) = P (fun buffer ->
  seq { for (v, buffer) in p1 buffer do
          let (P p2) = f v 
          yield! p2 buffer })

/// Represents a parser that always fails
let zero () = P (fun buffer -> Seq.empty)

/// Non-deterministic choice - combine all possible results
let combine (P p1) (P p2) = P (fun buffer ->
  Seq.concat [ p1 buffer; p2 buffer ])

/// Primitive parser that parses a char if it matches a predicate
let sat f = P (fun buffer -> seq { 
  match buffer with 
  | x::xs when f x -> yield x, xs 
  | _ -> () })

// Parsers that recognize single letter and number
let letter = sat System.Char.IsLetter
let number = sat System.Char.IsNumber
let letterOrDigit = sat System.Char.IsLetterOrDigit

/// Computation builder for working with parsers
type ParserBuilder() = 
  member x.Return(v) = unit v
  member x.ReturnFrom(m) = m
  member x.Bind(v, f) = bind f v
  member x.Zero() = zero()
  member x.Combine(p1, p2) = combine p1 p2
  member x.Delay(f) = P (fun buffer -> 
    let (P op) = f () in op buffer)

/// A unique instance of the computation builder
let parse = ParserBuilder()